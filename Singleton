Мотивація
Для деяких класів важливо, щоб існував тільки один екземпляр. Наприклад, хоча у системі може існувати декілька принтерів, може бути тільки один спулер. Повинна бути тільки одна файлова система та тільки один активний віконний менеджер.

Глобальна змінна не вирішує такої проблеми, бо не забороняє створити інші екземпляри класу.

Рішення полягає в тому, щоб сам клас контролював свою «унікальність», забороняючи створення нових екземплярів, та сам забезпечував єдину точку доступу. Це є призначенням шаблону Одинак.

Недоліки
Одинак в об'єктно-орієнтованому програмуванні можна порівняти з глобальною змінною у процедурному програмуванні з відповідними недоліками[1][2].

Зокрема, цей шаблон створює неявні залежності між функціями та методами, які не декларуються в їхньому інтерфейсі[1][3].

Крім того, Одинак може створювати проблеми під час модульного тестування адже, на додачу до всього іншого, його важко замінити на фіктивну реалізацію (англ. mock)[1][4][5].

Ці та інші недоліки спонукали Еріха Гаму в інтерв'ю 2009 року визнати, що можливо він би відмовився від цього шаблону проєктування, адже вважає його використання одним із «душків» коду[1].

На думку Брайана Батона Одинак порушує один із принципів SOLID: принцип єдиної відповідальності, оскільки окрім власне бізнес логіки, на клас покладається відповідальність за виконання вимог до Одинака. Натомість, він пропонує виокремити функціональність Одинака в інший клас, наприклад, із використанням шаблону фабричного метода або абстрактної фабрики[6].

Деякі з перелічених вад можна позбутись застосуванням шаблону впровадження залежностей та принципу інверсії залежностей[1].

Застосування
Слід використовувати шаблон Одинак коли:

повинен бути тільки один екземпляр деякого класу, що легко доступний всім клієнтам;
єдиний екземпляр повинен розширюватись шляхом успадкування, та клієнтам потрібно мати можливість працювати з розширеним екземпляром не змінюючи свій код.

Реалізації на C++
// Заголовний файл (.h)
//
// Ниттєбезпечна реалізація Одинака
//
// Ця версія виглядає оманливо просто, проте вона має застереження:
// - Перше, якщо одинак міститься в якійсь бібліотеці. Ті, хто використовуватимуть цю бібліотеку
// матимуть екземпляр одинака протягом роботи застосунка, незалежно
// від того, чи використовується він чи ні.
//
// - Друге, це випадок статичних залежностей файлів. Наприклад, уявімо що
// Singleton є якоюсь абстрактною фабрикою для типа BaseType, і
// застосовується метод create. Оскільки порядок ініціалізації статичних змінних
// протягом трансляції модулів не визначений, це може призвести
// до доступу до Одинака до моменту його конструювання, іншими словами
// до невизначеної поведінки, що є погана річ.
//
// namespace { const BaseType * const fileStaticVariable = Singleton::getInstance().create(); }
//
class Singleton
{
private: 
  static Singleton _instance;
 
  Singleton() {}
  ~Singleton() {} 	 
  Singleton(const Singleton &);	 
  Singleton & operator=(const Singleton &);
 
public:
  static Singleton& getInstance();
};
 
// Джерельний файл (.cpp)

// Ініціалізація статичного члена.
Singleton Singleton::_instance;

Singleton& Singleton::getInstance()
{
 return _instance;
}
